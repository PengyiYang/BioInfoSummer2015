---
title: "Stream C: Introduction to R Programming (BioinfoSummer 2015)"
author: "Pengyi Yang & Stephen Pederson"
output: html_document
---

The R programming language provides an effective environment for making sense of data that enables us to address various biological questions. In this introduction course, we will illustrate exploratory data analysis that involves calculating numerical and graphical summaries. More specially, we will cover installation of R packages, write basic R functions and examine various visualization tools.  For more intermediate participants in the course we will examine more complex visualization tools.


## Outline
- R data types and operations
- Read data in R and exploratory data analysis
- Install package and calling functions from packages
- Write your own functions
- Generating reports using RStudio

## R data types
#### Atomic data types and operations
Character 
```{r}
species <- "mouse"
```
Integer
```{r}
sampleSize <- 6
```
Numeric
```{r}
meanLifeSpan <- 2.05
```
Factor
```{r}
sex <- factor("male")
```
Boolean
```{r}
mammal <- TRUE
```
Concatenate characters
```{r}
strain <- "C57BL/6"
sampleDetail <- paste(species, strain)
sampleDetail
```


#### Primitive data types and operations
Vectors
```{r}
Groups <- c("treated", "control", "control", "control", "treated", "treated")
Groups
```
Calculate mean life span of sample population
```{r}
lifeSpans <- c(2.1, 1.9, 1.7, 1.8, 2.3, 2.5)
lifeSpans
mean(lifeSpans)
```
Split samples based on their groups
```{r}
sampleByGroup <- split(lifeSpans, Groups)
sampleByGroup # sampleByGroup is a list
```
Test if there is statistical significance of life span between the two groups of samples
```{r}
g1 <- sampleByGroup$treated
g2 <- sampleByGroup$control
t.test(g1, g2, alternative="greater")
```


## Read data in R and exploratory data analysis
Read in a tab-delimited dataset from plain text file and calculate summary statistics
```{r}
Adipo.dat <- read.delim("Adipogenesis.txt", head=TRUE)
Adipo.dat[1:5,]
```

subsetting a matrix
```{r}
Adipo.exp <- as.matrix(Adipo.dat[,-1]) # removing the ID column from the raw data to create a numeric matrix containing the expression of the genes at each time point
rownames(Adipo.exp) <- Adipo.dat[,1] # assign the row names of the matrix as the ID in the first column
Adipo.exp[1:5,] # displaying the first five rows of the expression matrix
summary(Adipo.exp)
```

Read data from R data object
```{r}
load("DEGs.RData") # This data contains differentially expressed genes
# subset the expression matrix to select only DE gene experssions
Adip.exp.DEGs <- Adipo.exp[DEGs,]
```




## Exploratory data analysis and visualisation
boxplot
```{r}
par(mfrow=c(1, 2))
boxplot(Adipo.exp, ylab="log2 Fold Change", main="Full dataset")
boxplot(Adip.exp.DEGs, ylab="log2 Fold Change", main="DE dataset")
```


```{r}
par(mfrow=c(1, 2))
# Scatter plot the full data and highlight the DE genes in the scatter plot
plot(Adipo.exp[,c("t8h", "t48h")])
points(Adipo.exp[DEGs,c("t8h", "t48h")], pch="*", col="red", main="8h vs 48h")
# generating pairwise correlation plots
plot(Adipo.exp[,c("t4h", "t48h")])
points(Adipo.exp[DEGs,c("t4h", "t48h")], pch="*", col="red", main="4h vs 48h")
```

library(corrplot)
corrplot(cor(Adip.exp.DEGs, use="na.or.complete"), addCoef.col="red")

plot(Adipo.exp[,"X4h"], Adipo.exp[,"X8h"])
abline(h=0, v=0, col="gold")


## This part will serves as the more advanced case study for participants who have more experience with R
## Install R packages and runing Using cluster evaluation algorithm to determine optimal clusters in the time-series 
Install a package called ClueR from CRAN (The Comprehensive R Archive Network)

install.packages("ClueR", repos='http://cran.us.r-project.org')
data(Pathways)


clueObj <- runClue(Tc=wt.times, annotation=Pathways.KEGG, rep = 5, kRange=20)


Ms <- apply(clueObj$evlMat, 2, mean, na.rm=TRUE)
Ss <- apply(clueObj$evlMat, 2, sd, na.rm=TRUE)
library(Hmisc)
errbar(1:length(Ms), Ms, Ms+Ss, Ms-Ss, cex=1.2, type="b", xaxt="n", xlab="k", ylab="E")
axis(1, at=1:12, labels=paste("k=", 2:13, sep=""))
# generate the optimal clustering results
best <- clustOptimal(clueObj, rep=10, user.maxK = 17, mfrow=c(4, 5))
# list enriched clusters
best$enrichList





